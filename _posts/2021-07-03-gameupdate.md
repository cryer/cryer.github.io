---
layout: post
mermaid: true
title: è”æœºæ¸¸æˆçƒ­æ›´æ–°å‘å¸ƒåŸç†
description: è”æœºæ¸¸æˆçƒ­æ›´æ–°å‘å¸ƒåŸç†

---

### å¯¼å…¥

ä¹‹å‰å‘å¸ƒäº†ä¸¤ç¯‡è®²è”æœºæ¸¸æˆåŸç†çš„åšå®¢ï¼Œç„¶åæœ€è¿‘åœ¨é‚®ç®±æ”¶åˆ°ä¸€ä¸ªè¯»è€…çš„é‚®ä»¶ï¼Œå‘æˆ‘è¯·æ•™è”æœºæ¸¸æˆä¸­æ›´æ–°çš„é—®é¢˜ï¼Œå› æ­¤æˆ‘å°±å†™äº†ä¸€ä¸ªä¾‹å­ï¼Œé€šè¿‡è¿™ç¯‡åšå®¢ç®€å•è¿›è¡Œè¯´æ˜ã€‚

è”æœºæ¸¸æˆæ›´æ–°ä½œè€…è§‰å¾—ä¸»è¦æœ‰ä¸¤ç±»ï¼š

- çƒ­è¡¥ä¸æ›´æ–°ï¼šæ— éœ€é‡æ–°ä¸‹è½½å’Œé€€å‡ºå®¢æˆ·ç«¯ï¼Œå®æ—¶å°±ç”Ÿæ•ˆçš„è¡¥ä¸æ›´æ–°ï¼Œä¸€èˆ¬åŒ…æ‹¬UIç•Œé¢èµ„æºï¼ˆæ¯”å¦‚éŸ³æ•ˆã€å›¾ç‰‡ç­‰èµ„æºæ–‡ä»¶ï¼‰ï¼Œè„šæœ¬é€»è¾‘ï¼Œæ¸¸æˆé…ç½®æ•°æ®ï¼Œéæ ¸å¿ƒçš„æ¸¸æˆé€»è¾‘ç­‰

- ç‰ˆæœ¬æ›´æ–°å’Œå†·è¡¥ä¸ï¼šå®‰å…¨æ€§ä¿®å¤ï¼Œæ ¸å¿ƒæ¸¸æˆå†…å®¹æ›´æ–°ï¼Œå…³é”®æ•°æ®ç»“æ„é‡æ„ï¼Œæ”¹å˜äº†äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œéœ€è¦é€€å‡ºæ¸¸æˆï¼Œé‡æ–°ä¸‹è½½ï¼Œå½“ç„¶ä¸€èˆ¬æ˜¯å¢é‡ä¸‹è½½ï¼Œæ‰èƒ½å®Œæˆæ›´æ–°ï¼Œå†æ¬¡è¿›å…¥æ¸¸æˆ

è¿™ç¯‡åšå®¢ä¸»è¦è®²è§£çƒ­è¡¥ä¸æ›´æ–°çš„æ–¹å¼ï¼Œç„¶åç¨å¾®ç®€å•è¯´æ˜ç¬¬äºŒç§æ›´æ–°æ–¹å¼ã€‚æ‰€è°“çƒ­è¡¥ä¸å°±æ˜¯ä¸å½±å“ç©å®¶æ¸¸ç©çš„æƒ…å†µä¸‹å¯ä»¥å¯¹å®¢æˆ·ç«¯è¿›è¡Œçš„ä¿®æ”¹ï¼Œå®æ—¶ç”Ÿæ•ˆï¼Œéå¸¸çµæ´»ã€‚æ¯”å¦‚UIå›¾ç‰‡èµ„æºï¼Œä¸¾ä¸ªä¾‹å­ï¼Œåˆ°æ—¶é—´ç‚¹å°±ä¿®æ”¹æ¸¸æˆä¸»é¡µå±•ç¤ºçš„å›¾ç‰‡ï¼›è¿˜æœ‰æ¯”å¦‚æ¸¸æˆé€»è¾‘çš„ä¿®æ”¹ã€‚æ²¡é”™ï¼Œç°ä»£æ¸¸æˆç¼–å†™ä¸€èˆ¬æ˜¯è„šæœ¬è¯­è¨€ç¼–å†™æ ¸å¿ƒæ¸¸æˆé€»è¾‘ï¼Œç„¶åå®¢æˆ·ç«¯åŠ¨æ€åŠ è½½è„šæœ¬è¯­è¨€ï¼Œå› æ­¤å¯ä»¥å®ç°çƒ­è¡¥ä¸ç›´æ¥æ›´æ–°ã€‚æ¯”å¦‚unityç”¨C#ç¼–å†™æ¸¸æˆï¼Œç„¶åå¯ä»¥ç”¨luaè„šæœ¬è¯­è¨€ç¼–å†™å†…éƒ¨æ¸¸æˆè¿è¡Œé€»è¾‘ï¼Œç„¶åluaè„šæœ¬å¯ä»¥åŠ¨æ€ä¸‹è½½æ›¿æ¢å’Œä¿®æ”¹ï¼Œå½“ç„¶unityè¿˜æœ‰`AssetBundle`çš„çƒ­æ›´æ–°æ–¹å¼ï¼Œå¯ä»¥ç”¨`AssetBundle.LoadAsset()` åŠ¨æ€åŠ è½½æ‰“åŒ…å¥½çš„`.assetbundle`æ–‡ä»¶ã€‚

å®ç°çš„ç¨‹åºé€šè¿‡æœåŠ¡å™¨ç«¯å¼€å¯ä¸€ä¸ª`Flask`æµè§ˆå™¨é¡µé¢ï¼Œä»è¿™ä¸ªåå°webé¡µé¢ä¸­å‘å¸ƒçƒ­æ›´æ–°ã€‚

### æ ¸å¿ƒåŸç†

#### TCP æ¶ˆæ¯åè®®ï¼ˆå¸¦é•¿åº¦å‰ç¼€ï¼‰

å¯ä»¥é¿å…é¿å…ç²˜åŒ…/åŠåŒ…é—®é¢˜ï¼Œé‡‡ç”¨`[4å­—èŠ‚é•¿åº¦å¤´][JSONæ¶ˆæ¯ä½“]`çš„æ•°æ®åŒ…æ ¼å¼ã€‚

```python
# å‘é€
json_data = json.dumps(msg).encode('utf-8')
length_prefix = len(json_data).to_bytes(4, 'big')
socket.sendall(length_prefix + json_data)

# æ¥æ”¶
length_data = recv_all(4)
msg_length = int.from_bytes(length_data, 'big')
msg_data = recv_all(msg_length)
```

#### çƒ­æ›´æ–°è„šæœ¬æ‰§è¡Œæœºåˆ¶

ä½¿ç”¨ Python å†…ç½® `exec()` å®ç°åŠ¨æ€è„šæœ¬åŠ è½½ï¼š

```python
local_scope = {}
exec(script_content, {}, local_scope)
if 'update_ball_position' in local_scope:
    self.script_logic = local_scope['update_ball_position']
```

- âœ… ä¼˜ç‚¹ï¼šçµæ´»ï¼Œå¯ä¿®æ”¹ä»»æ„é€»è¾‘
- âš ï¸ é£é™©ï¼šéœ€åšæ²™ç®±éš”ç¦»ï¼ˆæœ¬é¡¹ç›®ç®€åŒ–å¤„ç†ï¼‰

#### èƒŒæ™¯èµ„æºçƒ­æ›´æ–°åŸç†

```python
# Base64è§£ç å¹¶åŠ è½½å›¾ç‰‡
image_data = base64.b64decode(bg_config["background_image"])
image_file = io.BytesIO(image_data)
background_surface = pygame.image.load(image_file)
```

#### èµ„æºå¼‚æ­¥åŠ è½½æœºåˆ¶

ä½¿ç”¨ `queue.Queue` + å­çº¿ç¨‹å®ç°çº¿ç¨‹å®‰å…¨é€šä¿¡ï¼š

```python
# å­çº¿ç¨‹åŠ è½½å®Œæˆå
self.background_load_queue.put({
    "type": "background_loaded",
    "surface": pygame_surface,
    "version": version
})

# ä¸»çº¿ç¨‹æ¯å¸§è½®è¯¢
while not self.background_load_queue.empty():
    msg = self.background_load_queue.get_nowait()
    if msg["type"] == "background_loaded":
        self.background_config["background_surface"] = msg["surface"]
```

#### Web å›¾ç‰‡ä¸Šä¼  Base64 è½¬æ¢

å‰ç«¯ JavaScript å®ç°ï¼š

```js
const reader = new FileReader();
reader.onload = function(e) {
    const base64String = e.target.result.split(',')[1].replace(/\s/g, '');
    document.getElementById('bgImage').value = base64String;
};
reader.readAsDataURL(file);
```

#### å¿ƒè·³ä¸è¿æ¥ä¿æ´»æœºåˆ¶

- å®¢æˆ·ç«¯æ¯ 10 ç§’å‘é€å¿ƒè·³åŒ…
- æœåŠ¡å™¨è®°å½•æœ€åæ´»è·ƒæ—¶é—´
- è¿æ¥å¼‚å¸¸æ—¶è‡ªåŠ¨é‡è¿
- æœåŠ¡å™¨ä¸å› å•æ¬¡é”™è¯¯æ–­å¼€å®¢æˆ·ç«¯

```python
def send_heartbeat(self):
    while self.running:
        try:
            # å‘é€å¿ƒè·³
            self.socket.sendall(...)
        except:
            # é‡è¿
            self.socket = None
            self.connect_to_server()
        time.sleep(10)
```

### æ¶æ„è§£æ

**æœåŠ¡å™¨**ï¼š

- **æ¸¸æˆæœåŠ¡å™¨**ï¼šå¤„ç†å®¢æˆ·ç«¯è¿æ¥ï¼Œæ¨é€çƒ­æ›´æ–°
- **Webé…ç½®ç•Œé¢**ï¼šåŸºäºFlaskçš„ç®¡ç†åå°ï¼Œå®æ—¶å‘å¸ƒçƒ­è¡¥ä¸
- **çƒ­æ›´æ–°é…ç½®ç®¡ç†**ï¼šå­˜å‚¨è„šæœ¬é€»è¾‘å’ŒèƒŒæ™¯é…ç½®

**å®¢æˆ·ç«¯**ï¼š

- **Pygame UIç•Œé¢**ï¼šæ˜¾ç¤ºç§»åŠ¨çš„å°çƒå’ŒèƒŒæ™¯
- **çƒ­æ›´æ–°æ¥æ”¶å™¨**ï¼šç›‘å¬æœåŠ¡å™¨æ¨é€çš„æ›´æ–°
- **åŠ¨æ€è„šæœ¬æ‰§è¡Œå™¨**ï¼šä½¿ç”¨`exec()`åŠ¨æ€åŠ è½½æ–°é€»è¾‘
- **èµ„æºç®¡ç†å™¨**ï¼šå¤„ç†èƒŒæ™¯å›¾ç‰‡çš„åŠ¨æ€åŠ è½½

**æ¶æ„å›¾**ï¼š

```
+---------------------+     TCP Socket     +---------------------+
|   Pygame Client     | <----------------> |   Game Server       |
|  - æ¸¸æˆä¸»å¾ªç¯       |   (å¸¦é•¿åº¦å‰ç¼€)     |  - å®¢æˆ·ç«¯è¿æ¥ç®¡ç†    |
|  - çƒ­æ›´æ–°æ¥æ”¶å™¨     |                   |  - å¿ƒè·³ç»´æŠ¤          |
|  - å¼‚æ­¥èµ„æºåŠ è½½     |                   +----------+----------+
+----------+----------+                              |
           |                                         |
           | HTTP API                                |  TCP Push
           v                                         v
+---------------------+                   +---------------------+
|   Web Admin Panel   |                   |   Hot Update Config |
|  - è„šæœ¬ç¼–è¾‘å™¨       | <--------------- |  - script_logic     |
|  - å›¾ç‰‡ä¸Šä¼ è½¬Base64 |    RESTful API   |  - background_config|
+---------------------+                   +---------------------+
```


**çƒ­æ›´æ–°æµç¨‹å›¾ï¼ˆä»¥å›¾ç‰‡çƒ­è¡¥ä¸ä¸ºä¾‹ï¼‰**ï¼š

```mermaid
sequenceDiagram
    participant Admin as ç®¡ç†å‘˜
    participant Web as Webç•Œé¢
    participant Server as æ¸¸æˆæœåŠ¡å™¨
    participant Client as æ¸¸æˆå®¢æˆ·ç«¯
    participant UI as Pygameä¸»çº¿ç¨‹

    Admin->>Web: é€‰æ‹©æœ¬åœ°å›¾ç‰‡
    Web->>Web: è½¬ä¸ºBase64
    Admin->>Web: ç‚¹å‡»â€œå‘å¸ƒæ›´æ–°â€
    Web->>Server: POST /api/update_background
    Server->>Server: ä¿å­˜é…ç½®ï¼Œç‰ˆæœ¬+1
    Server->>Client: æ¨é€ {type: "hot_update", update_type: "background_config", ...}
    Client->>Client: å¯åŠ¨å¼‚æ­¥çº¿ç¨‹åŠ è½½å›¾ç‰‡
    Client->>UI: é€šè¿‡Queueä¼ é€’åŠ è½½å®Œæˆæ¶ˆæ¯
    UI->>UI: åº”ç”¨æ–°èƒŒæ™¯ï¼Œç§»é™¤â€œåŠ è½½ä¸­â€æç¤º
    Client->>Server: å‘é€ACKç¡®è®¤
```

### å®Œæ•´ä»£ç ï¼š

ä¸ºäº†æ–¹ä¾¿ï¼Œç›´æ¥é›†æˆå®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ç«¯åœ¨ä¸€èµ·ï¼š

```python
import os
import sys
import json
import time
import threading
import socket
import hashlib
from datetime import datetime
import importlib.util
import queue
import select

# ============ æœåŠ¡å™¨ç«¯ï¼ˆå¸¦Webé…ç½®ç•Œé¢ï¼‰ ============
from flask import Flask, render_template_string, request, jsonify, send_file
import base64

class HotUpdateServer:
    def __init__(self, game_server_port=8888, web_port=5000):
        self.game_server_port = game_server_port
        self.web_port = web_port
        self.clients = {}
        self.running = True

        # çƒ­æ›´æ–°é…ç½® - å­˜å‚¨åœ¨å†…å­˜ä¸­ï¼Œå®é™…é¡¹ç›®åº”æŒä¹…åŒ–
        self.hot_update_config = {
            "script_logic": {
                "version": "1.0.0",
                "last_update": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "content": """# é»˜è®¤ç§»åŠ¨é€»è¾‘
def update_ball_position(ball_x, ball_y, ball_speed_x, ball_speed_y, screen_width, screen_height):
    # åŸºç¡€ç§»åŠ¨é€»è¾‘
    ball_x += ball_speed_x
    ball_y += ball_speed_y

    # è¾¹ç•Œæ£€æµ‹
    if ball_x <= 0 or ball_x >= screen_width - 30:
        ball_speed_x = -ball_speed_x
    if ball_y <= 0 or ball_y >= screen_height - 30:
        ball_speed_y = -ball_speed_y

    return ball_x, ball_y, ball_speed_x, ball_speed_y
""",
                "enabled": True
            },
            "background_config": {
                "version": "1.0.0",
                "last_update": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "background_color": [30, 40, 50],
                "background_image": None,  # Base64ç¼–ç çš„å›¾ç‰‡æ•°æ®
                "enabled": True
            }
        }

        # åˆ›å»ºFlaskåº”ç”¨
        self.app = Flask(__name__)
        self.setup_routes()

        # åˆ›å»ºç¤ºä¾‹èƒŒæ™¯å›¾ç‰‡ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
        self.create_sample_background()

    def create_sample_background(self):
        """åˆ›å»ºç¤ºä¾‹èƒŒæ™¯å›¾ç‰‡"""
        try:
            from PIL import Image, ImageDraw
            import io

            # åˆ›å»ºä¸€ä¸ªç®€å•çš„æ¸å˜èƒŒæ™¯
            width, height = 800, 600
            image = Image.new('RGB', (width, height), (30, 40, 50))
            draw = ImageDraw.Draw(image)

            # æ·»åŠ ä¸€äº›è£…é¥°æ€§çº¿æ¡
            for i in range(0, width, 50):
                alpha = int(255 * (i / width))
                draw.line([(i, 0), (i, height)], fill=(100, 150, 200, alpha), width=1)

            for i in range(0, height, 50):
                alpha = int(255 * (i / height))
                draw.line([(0, i), (width, i)], fill=(100, 150, 200, alpha), width=1)

            # ä¿å­˜ä¸ºbase64
            buffered = io.BytesIO()
            image.save(buffered, format="PNG")
            img_str = base64.b64encode(buffered.getvalue()).decode('utf-8')

            self.hot_update_config["background_config"]["background_image"] = img_str

        except ImportError:
            print("PILæœªå®‰è£…ï¼Œä½¿ç”¨çº¯è‰²èƒŒæ™¯")
            pass

    def setup_routes(self):
        """è®¾ç½®Webè·¯ç”±"""

        @self.app.route('/')
        def index():
            return render_template_string(self.get_html_template())

        @self.app.route('/api/config')
        def get_config():
            return jsonify(self.hot_update_config)

        @self.app.route('/api/update_script', methods=['POST'])
        def update_script():
            data = request.json
            new_script = data.get('script', '')
            new_version = data.get('version', '1.0.0')

            if new_script:
                self.hot_update_config["script_logic"]["content"] = new_script
                self.hot_update_config["script_logic"]["version"] = new_version
                self.hot_update_config["script_logic"]["last_update"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

                # é€šçŸ¥æ‰€æœ‰å®¢æˆ·ç«¯æ›´æ–°
                self.notify_clients_update("script_logic")

                return jsonify({"success": True, "message": "è„šæœ¬æ›´æ–°æˆåŠŸ"})
            else:
                return jsonify({"success": False, "message": "è„šæœ¬å†…å®¹ä¸èƒ½ä¸ºç©º"})

        @self.app.route('/api/update_background', methods=['POST'])
        def update_background():
            data = request.json
            bg_color = data.get('background_color', [30, 40, 50])
            bg_image = data.get('background_image', None)
            new_version = data.get('version', '1.0.0')

            # ç¡®ä¿ Base64 å­—ç¬¦ä¸²æ˜¯æ™®é€šå­—ç¬¦ä¸²ï¼ˆé¿å…äºŒè¿›åˆ¶å¹²æ‰°ï¼‰
            if bg_image is not None:
                if isinstance(bg_image, str):
                    # æ¸…ç†å¯èƒ½çš„æ¢è¡Œæˆ–ç©ºæ ¼
                    bg_image = bg_image.strip().replace('\n', '').replace('\r', '')
                else:
                    bg_image = None  # éå­—ç¬¦ä¸²ä¸€å¾‹è®¾ä¸º None

            self.hot_update_config["background_config"]["background_color"] = bg_color
            self.hot_update_config["background_config"]["background_image"] = bg_image
            self.hot_update_config["background_config"]["version"] = new_version
            self.hot_update_config["background_config"]["last_update"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            self.notify_clients_update("background_config")

            return jsonify({"success": True, "message": "èƒŒæ™¯é…ç½®æ›´æ–°æˆåŠŸ"})

        @self.app.route('/api/clients')
        def get_clients():
            client_list = []
            for client_id, info in self.clients.items():
                client_list.append({
                    "id": client_id,
                    "address": info["address"],
                    "version": info["version"],
                    "last_active": info["last_active"]
                })
            return jsonify(client_list)

    def notify_clients_update(self, update_type):
        """é€šçŸ¥æ‰€æœ‰å®¢æˆ·ç«¯æœ‰æ›´æ–°ï¼ˆä¿®å¤å¤§æ¶ˆæ¯å‘é€ï¼‰"""
        update_message = {
            "type": "hot_update",
            "update_type": update_type,
            "config": self.hot_update_config[update_type],
            "timestamp": time.time()
        }

        json_data = json.dumps(update_message, ensure_ascii=False).encode('utf-8')
        length_prefix = len(json_data).to_bytes(4, byteorder='big')  # 4å­—èŠ‚é•¿åº¦å¤´

        clients_to_remove = []
        for client_id, client_info in self.clients.items():
            try:
                # å…ˆå‘é€é•¿åº¦ï¼Œå†å‘é€æ•°æ®
                client_info["socket"].sendall(length_prefix + json_data)
            except Exception as e:
                print(f"é€šçŸ¥å®¢æˆ·ç«¯ {client_id} å¤±è´¥: {e}")
                clients_to_remove.append(client_id)

        for client_id in clients_to_remove:
            if client_id in self.clients:
                del self.clients[client_id]

    def start_game_server(self):
        """å¯åŠ¨æ¸¸æˆæœåŠ¡å™¨"""
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server_socket.bind(('localhost', self.game_server_port))
        server_socket.listen(5)
        print(f"æ¸¸æˆæœåŠ¡å™¨å¯åŠ¨äº localhost:{self.game_server_port}")

        while self.running:
            try:
                client_socket, address = server_socket.accept()
                client_thread = threading.Thread(
                    target=self.handle_client,
                    args=(client_socket, address)
                )
                client_thread.daemon = True
                client_thread.start()
            except Exception as e:
                if self.running:
                    print(f"æ¸¸æˆæœåŠ¡å™¨é”™è¯¯: {e}")
                break

        server_socket.close()

    def handle_client(self, client_socket, address):
        client_id = f"{address[0]}:{address[1]}"
        print(f"æ–°å®¢æˆ·ç«¯è¿æ¥: {client_id}")

        try:
            # æ¥æ”¶å®¢æˆ·ç«¯ä¿¡æ¯
            data = client_socket.recv(1024).decode('utf-8')
            client_info = json.loads(data)

            # ä¿å­˜å®¢æˆ·ç«¯ä¿¡æ¯
            self.clients[client_id] = {
                "socket": client_socket,
                "address": address,
                "version": client_info.get("version", "unknown"),
                "last_active": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "alive": True  # æ ‡è®°å®¢æˆ·ç«¯å­˜æ´»çŠ¶æ€
            }

            # å‘é€å½“å‰çƒ­æ›´æ–°é…ç½®
            initial_config = {
                "type": "initial_config",
                "script_logic": self.hot_update_config["script_logic"],
                "background_config": self.hot_update_config["background_config"]
            }

            json_data = json.dumps(initial_config, ensure_ascii=False).encode('utf-8')
            length_prefix = len(json_data).to_bytes(4, byteorder='big')
            client_socket.sendall(length_prefix + json_data)

            print(f"å·²å‘å®¢æˆ·ç«¯ {client_id} å‘é€åˆå§‹é…ç½®")

            # ä¿æŒè¿æ¥ï¼Œä¸è¦å› ä¸€æ¬¡å¼‚å¸¸å°±æ–­å¼€
            while self.running and self.clients.get(client_id, {}).get("alive", False):
                try:
                    # ä½¿ç”¨ select é¿å…é•¿æ—¶é—´é˜»å¡
                    ready, _, _ = select.select([client_socket], [], [], 1.0)
                    if not ready:
                        continue

                    data = client_socket.recv(4)
                    if not data or len(data) < 4:
                        break

                    message_length = int.from_bytes(data, byteorder='big')
                    if message_length <= 0 or message_length > 10*1024*1024:
                        continue

                    message_data = b''
                    while len(message_data) < message_length:
                        chunk = client_socket.recv(min(4096, message_length - len(message_data)))
                        if not chunk:
                            break
                        message_data += chunk

                    if len(message_data) != message_length:
                        continue

                    message = json.loads(message_data.decode('utf-8'))

                    if message.get("type") == "heartbeat":
                        self.clients[client_id]["last_active"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    elif message.get("type") == "ack_update":
                        update_type = message.get("update_type")
                        print(f"å®¢æˆ·ç«¯ {client_id} ç¡®è®¤æ¥æ”¶ {update_type} æ›´æ–°")

                except (ConnectionResetError, ConnectionAbortedError) as e:
                    print(f"å®¢æˆ·ç«¯ {client_id} è¿æ¥å¼‚å¸¸: {e}")
                    break
                except Exception as e:
                    # ä¸è¦å› ä¸ºè§£æé”™è¯¯å°±æ–­å¼€è¿æ¥ï¼
                    print(f"å¤„ç†å®¢æˆ·ç«¯æ¶ˆæ¯æ—¶å‘ç”Ÿéè‡´å‘½é”™è¯¯: {e}")
                    continue  # ç»§ç»­å¾ªç¯ï¼Œä¿æŒè¿æ¥

        except Exception as e:
            print(f"å¤„ç†å®¢æˆ·ç«¯ {client_id} æ—¶å‡ºé”™: {e}")
        finally:
            if client_id in self.clients:
                self.clients[client_id]["alive"] = False
                del self.clients[client_id]
            try:
                client_socket.close()
            except:
                pass
            print(f"å®¢æˆ·ç«¯ {client_id} æ–­å¼€è¿æ¥")

    def get_html_template(self):
        """è¿”å›Webç•Œé¢HTMLæ¨¡æ¿"""
        return '''
<!DOCTYPE html>
<html>
<head>
    <title>æ¸¸æˆçƒ­æ›´æ–°ç®¡ç†åå°</title>
    <meta charset="utf-8">
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; }
        .card { background: white; padding: 20px; margin: 20px 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; border-bottom: 2px solid #007bff; padding-bottom: 10px; }
        h2 { color: #555; margin-top: 30px; }
        textarea { width: 100%; height: 300px; margin: 10px 0; padding: 10px; font-family: monospace; }
        input, button { padding: 8px 16px; margin: 5px; }
        button { background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #0056b3; }
        .clients-list { margin-top: 20px; }
        .client-item { padding: 10px; border: 1px solid #ddd; margin: 5px 0; border-radius: 4px; }
        .status { color: #28a745; }
        .config-item { margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 4px; }
        .version-info { color: #6c757d; font-size: 0.9em; }
        .update-log { background: #e9ecef; padding: 10px; border-radius: 4px; margin: 10px 0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>æ¸¸æˆçƒ­æ›´æ–°ç®¡ç†åå°</h1>

        <div class="card">
            <h2>å½“å‰è¿æ¥çš„å®¢æˆ·ç«¯</h2>
            <div id="clientsList" class="clients-list">
                <p>åŠ è½½ä¸­...</p>
            </div>
        </div>

        <div class="card">
            <h2>è„šæœ¬é€»è¾‘çƒ­æ›´æ–°</h2>
            <div class="config-item">
                <div class="version-info">
                    å½“å‰ç‰ˆæœ¬: <span id="scriptVersion">1.0.0</span><br>
                    æœ€åæ›´æ–°: <span id="scriptLastUpdate">-</span>
                </div>
                <textarea id="scriptContent" placeholder="è¾“å…¥Pythonè„šæœ¬é€»è¾‘..."></textarea>
                <div>
                    <input type="text" id="scriptNewVersion" placeholder="æ–°ç‰ˆæœ¬å·" value="1.1.0">
                    <button onclick="updateScriptLogic()">å‘å¸ƒè„šæœ¬æ›´æ–°</button>
                </div>
                <div class="update-log" id="scriptUpdateLog"></div>
            </div>
        </div>

        <div class="card">
            <h2>èƒŒæ™¯é…ç½®çƒ­æ›´æ–°</h2>
            <div class="config-item">
                <div class="version-info">
                    å½“å‰ç‰ˆæœ¬: <span id="bgVersion">1.0.0</span><br>
                    æœ€åæ›´æ–°: <span id="bgLastUpdate">-</span>
                </div>
                <div>
                    <h3>èƒŒæ™¯é¢œè‰²</h3>
                    <label>R: <input type="number" id="bgColorR" min="0" max="255" value="30"></label>
                    <label>G: <input type="number" id="bgColorG" min="0" max="255" value="40"></label>
                    <label>B: <input type="number" id="bgColorB" min="0" max="255" value="50"></label>
                </div>
                <div>
                    <h3>èƒŒæ™¯å›¾ç‰‡ (Base64)</h3>
                    <textarea id="bgImage" placeholder="ç²˜è´´Base64ç¼–ç çš„å›¾ç‰‡æ•°æ®..." rows="5"></textarea>
                    <div style="margin: 15px 0;">
                <input type="file" id="bgImageUpload" accept="image/*">
                <button onclick="loadImageAsBase64()">ä¸Šä¼ å¹¶è½¬æ¢</button>
                <span id="uploadStatus" style="color: #007bff; margin-left: 10px;"></span>
            </div>

            <script>
            function loadImageAsBase64() {
                const fileInput = document.getElementById('bgImageUpload');
                const file = fileInput.files[0];
                if (!file) {
                    alert('è¯·é€‰æ‹©ä¸€å¼ å›¾ç‰‡');
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(e) {
                    // æå– Base64 éƒ¨åˆ†å¹¶æ¸…ç†
                    let base64String = e.target.result.split(',')[1];
                    // ç§»é™¤æ‰€æœ‰æ¢è¡Œå’Œç©ºç™½ï¼ˆé¿å…JSONè§£æé—®é¢˜ï¼‰
                    base64String = base64String.replace(/\s/g, '');

                    document.getElementById('bgImage').value = base64String;
                    document.getElementById('uploadStatus').textContent = 'âœ… å›¾ç‰‡å·²è½¬æ¢ä¸º Base64';

                    // é¢„è§ˆ
                    const preview = document.createElement('img');
                    preview.src = e.target.result;
                    preview.style.maxWidth = '200px';
                    preview.style.marginTop = '10px';
                    preview.style.border = '1px solid #ccc';

                    const existingPreview = document.getElementById('imagePreview');
                    if (existingPreview) existingPreview.remove();
                    preview.id = 'imagePreview';
                    document.querySelector('#bgImage').parentNode.appendChild(preview);
                };
                reader.onerror = function() {
                    document.getElementById('uploadStatus').textContent = 'âŒ è¯»å–å¤±è´¥';
                };
                reader.readAsDataURL(file);
            }
            </script>
                    <p>æç¤º: å¯ä»¥ç•™ç©ºä½¿ç”¨çº¯è‰²èƒŒæ™¯</p>
                </div>
                <div>
                    <input type="text" id="bgNewVersion" placeholder="æ–°ç‰ˆæœ¬å·" value="1.1.0">
                    <button onclick="updateBackgroundConfig()">å‘å¸ƒèƒŒæ™¯æ›´æ–°</button>
                </div>
                <div class="update-log" id="bgUpdateLog"></div>
            </div>
        </div>
    </div>

    <script>
        // åŠ è½½åˆå§‹é…ç½®
        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                const config = await response.json();

                // æ›´æ–°è„šæœ¬é…ç½®æ˜¾ç¤º
                document.getElementById('scriptContent').value = config.script_logic.content;
                document.getElementById('scriptVersion').textContent = config.script_logic.version;
                document.getElementById('scriptLastUpdate').textContent = config.script_logic.last_update;

                // æ›´æ–°èƒŒæ™¯é…ç½®æ˜¾ç¤º
                const bgColor = config.background_config.background_color;
                document.getElementById('bgColorR').value = bgColor[0];
                document.getElementById('bgColorG').value = bgColor[1];
                document.getElementById('bgColorB').value = bgColor[2];
                document.getElementById('bgImage').value = config.background_config.background_image || '';
                document.getElementById('bgVersion').textContent = config.background_config.version;
                document.getElementById('bgLastUpdate').textContent = config.background_config.last_update;

                loadClients();
            } catch (error) {
                console.error('åŠ è½½é…ç½®å¤±è´¥:', error);
            }
        }

        // åŠ è½½å®¢æˆ·ç«¯åˆ—è¡¨
        async function loadClients() {
            try {
                const response = await fetch('/api/clients');
                const clients = await response.json();

                const clientsList = document.getElementById('clientsList');
                clientsList.innerHTML = '';

                if (clients.length === 0) {
                    clientsList.innerHTML = '<p>æš‚æ— å®¢æˆ·ç«¯è¿æ¥</p>';
                    return;
                }

                clients.forEach(client => {
                    const div = document.createElement('div');
                    div.className = 'client-item';
                    div.innerHTML = `
                        <strong>å®¢æˆ·ç«¯ID:</strong> ${client.id}<br>
                        <strong>ç‰ˆæœ¬:</strong> ${client.version}<br>
                        <strong>æœ€åæ´»è·ƒ:</strong> ${client.last_active}<br>
                        <span class="status">åœ¨çº¿</span>
                    `;
                    clientsList.appendChild(div);
                });
            } catch (error) {
                console.error('åŠ è½½å®¢æˆ·ç«¯åˆ—è¡¨å¤±è´¥:', error);
            }
        }

        // æ›´æ–°è„šæœ¬é€»è¾‘
        async function updateScriptLogic() {
            const scriptContent = document.getElementById('scriptContent').value;
            const newVersion = document.getElementById('scriptNewVersion').value;

            if (!scriptContent.trim()) {
                alert('è„šæœ¬å†…å®¹ä¸èƒ½ä¸ºç©º');
                return;
            }

            try {
                const response = await fetch('/api/update_script', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        script: scriptContent,
                        version: newVersion
                    })
                });

                const result = await response.json();

                const logDiv = document.getElementById('scriptUpdateLog');
                if (result.success) {
                    logDiv.innerHTML = `<p style="color: green;">âœ… ${new Date().toLocaleString()}: ${result.message}</p>` + logDiv.innerHTML;
                    document.getElementById('scriptVersion').textContent = newVersion;
                    document.getElementById('scriptLastUpdate').textContent = new Date().toLocaleString();
                } else {
                    logDiv.innerHTML = `<p style="color: red;">âŒ ${new Date().toLocaleString()}: ${result.message}</p>` + logDiv.innerHTML;
                }
            } catch (error) {
                console.error('æ›´æ–°è„šæœ¬å¤±è´¥:', error);
                document.getElementById('scriptUpdateLog').innerHTML = 
                    `<p style="color: red;">âŒ ${new Date().toLocaleString()}: ç½‘ç»œé”™è¯¯</p>` + 
                    document.getElementById('scriptUpdateLog').innerHTML;
            }
        }

        // æ›´æ–°èƒŒæ™¯é…ç½®
        async function updateBackgroundConfig() {
            const bgColorR = parseInt(document.getElementById('bgColorR').value) || 0;
            const bgColorG = parseInt(document.getElementById('bgColorG').value) || 0;
            const bgColorB = parseInt(document.getElementById('bgColorB').value) || 0;
            const bgImage = document.getElementById('bgImage').value;
            const newVersion = document.getElementById('bgNewVersion').value;

            try {
                const response = await fetch('/api/update_background', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        background_color: [bgColorR, bgColorG, bgColorB],
                        background_image: bgImage || null,
                        version: newVersion
                    })
                });

                const result = await response.json();

                const logDiv = document.getElementById('bgUpdateLog');
                if (result.success) {
                    logDiv.innerHTML = `<p style="color: green;">âœ… ${new Date().toLocaleString()}: ${result.message}</p>` + logDiv.innerHTML;
                    document.getElementById('bgVersion').textContent = newVersion;
                    document.getElementById('bgLastUpdate').textContent = new Date().toLocaleString();
                } else {
                    logDiv.innerHTML = `<p style="color: red;">âŒ ${new Date().toLocaleString()}: ${result.message}</p>` + logDiv.innerHTML;
                }
            } catch (error) {
                console.error('æ›´æ–°èƒŒæ™¯é…ç½®å¤±è´¥:', error);
                document.getElementById('bgUpdateLog').innerHTML = 
                    `<p style="color: red;">âŒ ${new Date().toLocaleString()}: ç½‘ç»œé”™è¯¯</p>` + 
                    document.getElementById('bgUpdateLog').innerHTML;
            }
        }

        // å®šæ—¶åˆ·æ–°
        setInterval(loadClients, 5000);

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.onload = function() {
            loadConfig();
        };
    </script>
</body>
</html>
        '''

    def start(self):
        """å¯åŠ¨æœåŠ¡å™¨"""
        # å¯åŠ¨æ¸¸æˆæœåŠ¡å™¨çº¿ç¨‹
        game_server_thread = threading.Thread(target=self.start_game_server)
        game_server_thread.daemon = True
        game_server_thread.start()

        print(f"Webç®¡ç†ç•Œé¢å¯åŠ¨äº http://localhost:{self.web_port}")
        print("å¯ä»¥é€šè¿‡æµè§ˆå™¨å®æ—¶å‘å¸ƒçƒ­è¡¥ä¸ï¼")

        # å¯åŠ¨Flaskåº”ç”¨
        self.app.run(host='localhost', port=self.web_port, debug=False)


# ============ å®¢æˆ·ç«¯ï¼ˆPygame UIï¼‰ ============
import pygame
import io

class HotUpdateGameClient:
    def __init__(self, server_host='localhost', server_port=8888):
        self.server_host = server_host
        self.server_port = server_port
        self.socket = None
        self.running = True
        self.version = "1.0.0"

        # æ¸¸æˆçŠ¶æ€
        self.screen_width = 800
        self.screen_height = 600
        self.ball_x = 400
        self.ball_y = 300
        self.ball_speed_x = 3
        self.ball_speed_y = 2
        self.ball_radius = 15

        # çƒ­æ›´æ–°ç›¸å…³
        self.script_logic = None
        self.background_config = {
            "background_color": [30, 40, 50],
            "background_image": None,
            "background_surface": None
        }

        # åŠ¨æ€åŠ è½½æ¨¡å—çš„å­˜å‚¨
        self.dynamic_modules = {}

        # åˆå§‹åŒ–Pygame
        pygame.init()
        self.screen = pygame.display.set_mode((self.screen_width, self.screen_height))
        pygame.display.set_caption("çƒ­æ›´æ–°æ¸¸æˆå®¢æˆ·ç«¯")
        self.clock = pygame.time.Clock()

        # æ·»åŠ æ¶ˆæ¯é˜Ÿåˆ—å’Œæ¥æ”¶çº¿ç¨‹æ§åˆ¶
        self.update_queue = queue.Queue()
        self.receive_thread = None
        self.stop_receive = threading.Event()

        # æ›¿æ¢ pygame.eventï¼Œä½¿ç”¨çº¿ç¨‹å®‰å…¨é˜Ÿåˆ—
        self.background_load_queue = queue.Queue()

    def start_receive_thread(self):
        """å¯åŠ¨ç‹¬ç«‹çº¿ç¨‹æ¥æ”¶æœåŠ¡å™¨æ¶ˆæ¯"""
        if self.receive_thread and self.receive_thread.is_alive():
            return

        self.stop_receive.clear()
        self.receive_thread = threading.Thread(target=self.receive_updates_loop)
        self.receive_thread.daemon = True
        self.receive_thread.start()
        print("å·²å¯åŠ¨ç‹¬ç«‹æ¥æ”¶çº¿ç¨‹")

    def receive_updates_loop(self):
        """åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­æŒç»­æ¥æ”¶æœåŠ¡å™¨æ›´æ–°"""
        while not self.stop_receive.is_set() and self.socket:
            try:
                # ä½¿ç”¨ select æ£€æŸ¥ socket æ˜¯å¦å¯è¯»ï¼Œé¿å…é˜»å¡
                ready, _, _ = select.select([self.socket], [], [], 0.5)
                if not ready:
                    continue

                # è¯»å–é•¿åº¦å¤´
                length_data = b''
                while len(length_data) < 4 and not self.stop_receive.is_set():
                    try:
                        chunk = self.socket.recv(4 - len(length_data))
                        if not chunk:
                            break
                        length_data += chunk
                    except:
                        break

                if len(length_data) != 4:
                    continue

                message_length = int.from_bytes(length_data, byteorder='big')
                if message_length <= 0 or message_length > 10*1024*1024:
                    continue

                # è¯»å–å®Œæ•´æ¶ˆæ¯
                message_data = b''
                while len(message_data) < message_length and not self.stop_receive.is_set():
                    try:
                        chunk = self.socket.recv(min(4096, message_length - len(message_data)))
                        if not chunk:
                            break
                        message_data += chunk
                    except:
                        break

                if len(message_data) != message_length:
                    continue

                # è§£æå¹¶æ”¾å…¥é˜Ÿåˆ—
                try:
                    message_str = message_data.decode('utf-8')
                    message = json.loads(message_str)
                    self.update_queue.put(message)
                except Exception as e:
                    print(f"è§£ææœåŠ¡å™¨æ¶ˆæ¯å¤±è´¥: {e}")

            except Exception as e:
                if not self.stop_receive.is_set():
                    print(f"æ¥æ”¶çº¿ç¨‹é”™è¯¯: {e}")
                break

        print("æ¥æ”¶çº¿ç¨‹å·²é€€å‡º")


    def connect_to_server(self):
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.connect((self.server_host, self.server_port))
            print(f"è¿æ¥åˆ°æœåŠ¡å™¨ {self.server_host}:{self.server_port}")

            client_info = {
                'type': 'client_info',
                'version': self.version,
                'platform': 'Pygame Client'
            }
            self.socket.send(json.dumps(client_info).encode('utf-8'))

            # æ¥æ”¶å¸¦é•¿åº¦å‰ç¼€çš„åˆå§‹é…ç½®
            length_data = self.socket.recv(4)
            if len(length_data) != 4:
                raise Exception("æ¥æ”¶åˆå§‹é…ç½®é•¿åº¦å¤±è´¥")

            message_length = int.from_bytes(length_data, byteorder='big')
            message_data = b''
            while len(message_data) < message_length:
                chunk = self.socket.recv(min(4096, message_length - len(message_data)))
                if not chunk:
                    break
                message_data += chunk

            config = json.loads(message_data.decode('utf-8'))

            if config['type'] == 'initial_config':
                # å…ˆåŒæ­¥åº”ç”¨åˆå§‹é…ç½®ï¼ˆåŒ…æ‹¬å¯åŠ¨å¼‚æ­¥åŠ è½½ï¼‰
                self.apply_script_logic(config['script_logic'])
                self.apply_background_config(config['background_config'])
                print("åˆå§‹é…ç½®åŠ è½½å®Œæˆ")

                # ç­‰å¾…0.1ç§’ï¼Œç¡®ä¿å¼‚æ­¥åŠ è½½çº¿ç¨‹å·²å¯åŠ¨
                time.sleep(0.1)

                # å†å¯åŠ¨æ¥æ”¶çº¿ç¨‹å’Œå¿ƒè·³
                heartbeat_thread = threading.Thread(target=self.send_heartbeat)
                heartbeat_thread.daemon = True
                heartbeat_thread.start()
                # ç‹¬ç«‹çº¿ç¨‹æ¥æ”¶æœåŠ¡å™¨æ¶ˆæ¯
                self.start_receive_thread()

                return True

        except Exception as e:
            print(f"è¿æ¥æœåŠ¡å™¨å¤±è´¥: {e}")
            return False

    def send_heartbeat(self):
        """å‘é€å¿ƒè·³åŒ…ï¼ˆå¸¦é‡è¿ï¼‰"""
        while self.running:
            if not self.socket:
                print("å¿ƒè·³çº¿ç¨‹ï¼šsocket ä¸ºç©ºï¼Œå°è¯•é‡è¿...")
                if not self.connect_to_server():
                    time.sleep(5)
                    continue

            try:
                heartbeat = {
                    'type': 'heartbeat',
                    'timestamp': time.time()
                }
                json_data = json.dumps(heartbeat, ensure_ascii=False).encode('utf-8')
                length_prefix = len(json_data).to_bytes(4, byteorder='big')
                self.socket.sendall(length_prefix + json_data)
            except Exception as e:
                print(f"å¿ƒè·³å‘é€å¤±è´¥: {e}")
                # å…³é—­å½“å‰ socketï¼Œä¸‹æ¬¡å¾ªç¯å°è¯•é‡è¿
                try:
                    self.socket.close()
                except:
                    pass
                self.socket = None
            time.sleep(10)

    def apply_script_logic(self, script_config):
        """åº”ç”¨è„šæœ¬é€»è¾‘çƒ­æ›´æ–°"""
        try:
            script_content = script_config['content']
            version = script_config['version']

            # åŠ¨æ€æ‰§è¡Œè„šæœ¬
            local_scope = {}
            # åŸå‹ï¼š exec(source, globals=None, locals=None)
            exec(script_content, {}, local_scope)

            # æ£€æŸ¥æ˜¯å¦åŒ…å«éœ€è¦çš„å‡½æ•°
            if 'update_ball_position' in local_scope:
                self.script_logic = local_scope['update_ball_position']
                print(f"è„šæœ¬é€»è¾‘çƒ­æ›´æ–°æˆåŠŸï¼ç‰ˆæœ¬: {version}")

                # ä¿å­˜åˆ°åŠ¨æ€æ¨¡å—ä¸­
                self.dynamic_modules['script_logic'] = {
                    'module': local_scope,
                    'version': version,
                    'last_update': script_config.get('last_update', '')
                }

                return True
            else:
                print("è„šæœ¬ä¸­æœªæ‰¾åˆ° update_ball_position å‡½æ•°")
                return False

        except Exception as e:
            print(f"åº”ç”¨è„šæœ¬é€»è¾‘å¤±è´¥: {e}")
            return False

    def apply_background_config(self, bg_config):
        """åº”ç”¨èƒŒæ™¯é…ç½®çƒ­æ›´æ–°ï¼ˆä½¿ç”¨é˜Ÿåˆ—é€šä¿¡ï¼‰"""
        try:
            self.background_config["background_color"] = bg_config["background_color"]
            new_bg_image = bg_config["background_image"]
            version = bg_config["version"]

            if new_bg_image and new_bg_image != self.background_config.get("background_image_raw"):
                print(f"å¼€å§‹å¼‚æ­¥åŠ è½½èƒŒæ™¯å›¾ç‰‡ (ç‰ˆæœ¬: {version})...")
                self.background_config["background_image_raw"] = new_bg_image
                self.background_config["loading"] = True

                def load_background_async():
                    try:
                        image_data = base64.b64decode(new_bg_image)
                        image_file = io.BytesIO(image_data)
                        surface = pygame.image.load(image_file)
                        surface = pygame.transform.scale(surface, (self.screen_width, self.screen_height))

                        # ä½¿ç”¨ queue ä¼ é€’ï¼Œè€Œä¸æ˜¯ pygame.event
                        self.background_load_queue.put({
                            "type": "background_loaded",
                            "surface": surface,
                            "version": version
                        })
                        print(f"âœ… [åŠ è½½çº¿ç¨‹] èƒŒæ™¯å›¾ç‰‡åŠ è½½å®Œæˆï¼Œå·²æ”¾å…¥é˜Ÿåˆ— (ç‰ˆæœ¬: {version})")

                    except Exception as e:
                        print(f"âŒ [åŠ è½½çº¿ç¨‹] å¼‚æ­¥åŠ è½½èƒŒæ™¯å›¾ç‰‡å¤±è´¥: {e}")
                        self.background_load_queue.put({
                            "type": "background_load_failed",
                            "error": str(e),
                            "version": version
                        })

                threading.Thread(target=load_background_async, daemon=True).start()

            elif not new_bg_image:
                self.background_config["background_surface"] = None
                self.background_config["background_image_raw"] = None
                self.background_config["loading"] = False
                self.background_config["version"] = version
                self.background_config["last_update"] = bg_config.get("last_update", "")
                print(f"ğŸ–¼ï¸ åˆ‡æ¢åˆ°çº¯è‰²èƒŒæ™¯ (ç‰ˆæœ¬: {version})")

            return True

        except Exception as e:
            print(f"åº”ç”¨èƒŒæ™¯é…ç½®å¤±è´¥: {e}")
            return False

    def handle_server_updates(self):
        """ä»é˜Ÿåˆ—ä¸­å¤„ç†æœåŠ¡å™¨æ›´æ–°ï¼ˆéé˜»å¡ï¼‰"""
        while not self.update_queue.empty():
            try:
                message = self.update_queue.get_nowait()

                if message['type'] == 'hot_update':
                    update_type = message['update_type']
                    config = message['config']

                    print(f"æ”¶åˆ°çƒ­æ›´æ–°: {update_type} (ç‰ˆæœ¬: {config['version']})")

                    if update_type == 'script_logic':
                        success = self.apply_script_logic(config)
                    elif update_type == 'background_config':
                        success = self.apply_background_config(config)

                    # å‘é€ç¡®è®¤ï¼ˆç”¨åŸsocketï¼Œä½†é¢‘ç‡å¾ˆä½ï¼Œä¸ä¼šå¡é¡¿ï¼‰
                    try:
                        ack_message = {
                            'type': 'ack_update',
                            'update_type': update_type,
                            'success': success,
                            'version': config['version']
                        }
                        ack_json = json.dumps(ack_message, ensure_ascii=False).encode('utf-8')
                        ack_length = len(ack_json).to_bytes(4, byteorder='big')
                        self.socket.sendall(ack_length + ack_json)
                    except Exception as e:
                        print(f"å‘é€ACKå¤±è´¥: {e}")

            except queue.Empty:
                break
            except Exception as e:
                print(f"å¤„ç†é˜Ÿåˆ—æ¶ˆæ¯æ—¶å‡ºé”™: {e}")

    def update_game_logic(self):
        """æ›´æ–°æ¸¸æˆé€»è¾‘"""
        if self.script_logic:
            # ä½¿ç”¨çƒ­æ›´æ–°çš„è„šæœ¬é€»è¾‘
            self.ball_x, self.ball_y, self.ball_speed_x, self.ball_speed_y = self.script_logic(
                self.ball_x, self.ball_y, self.ball_speed_x, self.ball_speed_y,
                self.screen_width, self.screen_height
            )
        else:
            # ä½¿ç”¨é»˜è®¤é€»è¾‘
            self.ball_x += self.ball_speed_x
            self.ball_y += self.ball_speed_y

            # è¾¹ç•Œæ£€æµ‹
            if self.ball_x <= 0 or self.ball_x >= self.screen_width - 30:
                self.ball_speed_x = -self.ball_speed_x
            if self.ball_y <= 0 or self.ball_y >= self.screen_height - 30:
                self.ball_speed_y = -self.ball_speed_y

    def draw_game(self):
        """ç»˜åˆ¶æ¸¸æˆç”»é¢ï¼ˆä»é˜Ÿåˆ—è¯»å–èƒŒæ™¯åŠ è½½ç»“æœï¼‰"""

        # ä»é˜Ÿåˆ—ä¸­è·å–åŠ è½½ç»“æœ
        try:
            while True:  # æ¸…ç©ºé˜Ÿåˆ—ä¸­çš„æ‰€æœ‰æ¶ˆæ¯
                msg = self.background_load_queue.get_nowait()
                if msg["type"] == "background_loaded":
                    self.background_config["background_surface"] = msg["surface"]
                    self.background_config["version"] = msg["version"]
                    self.background_config["loading"] = False
                    print(f"âœ… [UIçº¿ç¨‹] èƒŒæ™¯å›¾ç‰‡å·²åº”ç”¨åˆ°ç•Œé¢ (ç‰ˆæœ¬: {msg['version']})")
                elif msg["type"] == "background_load_failed":
                    print(f"âŒ [UIçº¿ç¨‹] èƒŒæ™¯åŠ è½½å¤±è´¥: {msg['error']}")
                    self.background_config["loading"] = False
        except queue.Empty:
            pass  # é˜Ÿåˆ—ç©ºäº†ï¼Œæ­£å¸¸æƒ…å†µ


        #  ç»˜åˆ¶èƒŒæ™¯
        if self.background_config.get("loading"):
            bg_color = self.background_config["background_color"]
            self.screen.fill(bg_color)
            try:
                font = pygame.font.Font("STSONG.TTF", 36)
            except:
                font = pygame.font.SysFont(["Microsoft YaHei", "SimHei"], 36)
            loading_text = font.render("èƒŒæ™¯å›¾ç‰‡åŠ è½½ä¸­...", True, (255, 255, 0))
            text_rect = loading_text.get_rect(center=(self.screen_width//2, self.screen_height//2))
            self.screen.blit(loading_text, text_rect)
        elif self.background_config["background_surface"]:
            self.screen.blit(self.background_config["background_surface"], (0, 0))
        else:
            bg_color = self.background_config["background_color"]
            self.screen.fill(bg_color)

        # ç»˜åˆ¶å°çƒ
        pygame.draw.circle(self.screen, (255, 100, 100), (int(self.ball_x), int(self.ball_y)), self.ball_radius)


        script_version = self.dynamic_modules.get('script_logic', {}).get('version', 'é»˜è®¤')
        bg_version = self.background_config.get('version', 'é»˜è®¤')
        status = "åŠ è½½ä¸­..." if self.background_config.get("loading") else "æ­£å¸¸"

        try:
            font = pygame.font.Font("STSONG.TTF", 24)
        except:
            font = pygame.font.SysFont(["Microsoft YaHei", "SimHei"], 36)
        script_text = font.render(f"è„šæœ¬ç‰ˆæœ¬: {script_version}", True, (255, 255, 255))
        bg_text = font.render(f"èƒŒæ™¯ç‰ˆæœ¬: {bg_version} ({status})", True, (255, 255, 255))

        self.screen.blit(script_text, (10, 10))
        self.screen.blit(bg_text, (10, 40))

        pygame.display.flip()


    def run(self):
        """è¿è¡Œæ¸¸æˆä¸»å¾ªç¯"""
        if not self.connect_to_server():
            print("æ— æ³•è¿æ¥æœåŠ¡å™¨ï¼Œä½¿ç”¨é»˜è®¤é…ç½®è¿è¡Œ")
            # ä½¿ç”¨é»˜è®¤é…ç½®ç»§ç»­è¿è¡Œ
            pass

        print("æ¸¸æˆå¼€å§‹è¿è¡Œï¼æ”¯æŒçƒ­æ›´æ–°...")
        print("åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€ http://localhost:5000 å¯ä»¥å®æ—¶æ›´æ–°æ¸¸æˆé€»è¾‘å’ŒèƒŒæ™¯")

        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        self.running = False
                    elif event.key == pygame.K_SPACE:
                        # ç©ºæ ¼é”®é‡ç½®å°çƒä½ç½®
                        self.ball_x = 400
                        self.ball_y = 300
                        self.ball_speed_x = 3 if self.ball_speed_x > 0 else -3
                        self.ball_speed_y = 2 if self.ball_speed_y > 0 else -2

            # å¤„ç†æœåŠ¡å™¨æ›´æ–°
            self.handle_server_updates()

            # æ›´æ–°æ¸¸æˆé€»è¾‘
            self.update_game_logic()

            # ç»˜åˆ¶æ¸¸æˆç”»é¢
            self.draw_game()

            # æ§åˆ¶å¸§ç‡
            self.clock.tick(60)

        # æ¸…ç†èµ„æº
        pygame.quit()
        if self.socket:
            self.socket.close()
        print("æ¸¸æˆç»“æŸ")


# ============ å¯åŠ¨ç¨‹åº ============
def create_sample_game():
    """åˆ›å»ºç¤ºä¾‹æ¸¸æˆ"""
    print("=" * 60)
    print("Pygameçƒ­æ›´æ–°è”æœºæ¸¸æˆæ¼”ç¤º")
    print("=" * 60)
    print("æœ¬ç¤ºä¾‹å±•ç¤º:")
    print("1. å®¢æˆ·ç«¯ä½¿ç”¨Pygameåˆ›å»ºUIç•Œé¢")
    print("2. æœåŠ¡å™¨æä¾›Webé…ç½®é¡µé¢å®æ—¶å‘å¸ƒçƒ­è¡¥ä¸")
    print("3. æ”¯æŒä¸é‡å¯çš„è„šæœ¬é€»è¾‘çƒ­æ›´æ–°")
    print("4. æ”¯æŒä¸é‡å¯çš„èƒŒæ™¯èµ„æºçƒ­æ›´æ–°")
    print("=" * 60)

    # å¯åŠ¨æœåŠ¡å™¨
    server = HotUpdateServer(game_server_port=8888, web_port=5000)

    # åœ¨æ–°çº¿ç¨‹ä¸­å¯åŠ¨æœåŠ¡å™¨
    server_thread = threading.Thread(target=server.start)
    server_thread.daemon = True
    server_thread.start()

    print("ç­‰å¾…æœåŠ¡å™¨å¯åŠ¨...")
    time.sleep(3)

    print("\n" + "=" * 40)
    print("å¯åŠ¨Pygameå®¢æˆ·ç«¯...")
    print("=" * 40)

    # å¯åŠ¨å®¢æˆ·ç«¯
    client = HotUpdateGameClient()
    client.run()

    print("æ¼”ç¤ºç»“æŸ")


if __name__ == "__main__":
    # æ£€æŸ¥ä¾èµ–
    try:
        import pygame
        from flask import Flask
    except ImportError as e:
        print("ç¼ºå°‘ä¾èµ–åŒ…ï¼Œè¯·å®‰è£…:")
        print("pip install pygame flask Pillow")
        sys.exit(1)

    # è¿è¡Œç¤ºä¾‹
    create_sample_game()
```

ä»£ç å¹¶ä¸å¤æ‚ï¼Œåªæ˜¯å†™åˆ°äº†ä¸€èµ·ï¼Œå‰ç«¯ä»£ç å°±æœ‰è¿‘300è¡Œï¼Œé…åˆæ³¨é‡Šç›¸ä¿¡å¾ˆå¿«å°±å¯ä»¥çœ‹æ‡‚ã€‚åªæ˜¯è¦æ³¨æ„ä¸ºäº†è¿è¡Œçš„æ•ˆç‡ï¼Œè¦å–„ç”¨å¤šçº¿ç¨‹ï¼Œå°¤å…¶æ˜¯åå°çº¿ç¨‹ã€‚æ¯”å¦‚æœ€å¼€å§‹ç¨‹åºä¸»çº¿ç¨‹å°±æ˜¯å®¢æˆ·ç«¯ä¸»çº¿ç¨‹ï¼ŒæœåŠ¡å™¨ç«¯æ”¾åˆ°äº†åå°çº¿ç¨‹ï¼Œç„¶åå®¢æˆ·ç«¯ä¸»çº¿ç¨‹ä¸»è¦è´Ÿè´£ç›‘å¬äº‹ä»¶ï¼Œå¤„ç†æœåŠ¡å™¨æ›´æ–°ï¼Œæ›´æ–°æ¸¸æˆé€»è¾‘ï¼Œæ¸¸æˆç»˜åˆ¶ï¼Œå…¶ä¸­ï¼Œå¤„ç†æœåŠ¡å™¨æ›´æ–°ä¸»è¦å°±æ˜¯å¤„ç†åŸºæœ¬é€»è¾‘æ›´æ–°å’ŒèƒŒæ™¯æ›´æ–°ï¼Œè€ŒèƒŒæ™¯æ›´æ–°å› ä¸ºæ¶‰åŠåˆ°å›¾ç‰‡ï¼Œèµ„æºæ¯”è¾ƒå¤§ï¼Œä¹Ÿäº¤ç»™äº†åå°å•ç‹¬çº¿ç¨‹å¼‚æ­¥å¤„ç†ã€‚ç„¶åå›åˆ°æœåŠ¡å™¨ç«¯ï¼Œä¸»çº¿ç¨‹è´Ÿè´£å¼€å¯`Flask app`ï¼Œæ¸²æŸ“ç½‘é¡µå’Œé…ç½®è·¯ç”±ï¼Œåå°çº¿ç¨‹è´Ÿè´£å¯åŠ¨æœåŠ¡å™¨ï¼Œå¹¶ä¸”ç›‘å¬å®¢æˆ·ç«¯ï¼Œç„¶ååå°æœåŠ¡å™¨å¯åŠ¨çº¿ç¨‹ä¸­åˆå¼€äº†ä¸¤ä¸ªåå°çº¿ç¨‹ï¼Œä¸€ä¸ªè´Ÿè´£å¿ƒè·³åŒ…çš„å‘é€ï¼Œä¸€ä¸ªè´Ÿè´£å¤„ç†å®é™…çš„å®¢æˆ·ç«¯è¿æ¥ï¼Œå¹¶ä¸”å¾ªç¯æ¥æ”¶å®¢æˆ·ç«¯æ•°æ®ã€‚

### æ•ˆæœ

å…ˆçœ‹æœåŠ¡å™¨ç«¯çš„webçƒ­æ›´æ–°é…ç½®é¡µé¢ï¼š

![](https://github.com/cryer/cryer.github.io/raw/master/image/151.jpg)

è¿™å°±æ˜¯æ¸¸æˆæ ¸å¿ƒé€»è¾‘çš„æ›´æ–°çƒ­è¡¥ä¸é…ç½®ï¼ŒåŸæ¥æ˜¯é»˜è®¤ç›´çº¿çš„è¿åŠ¨è½¨è¿¹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

![](https://github.com/cryer/cryer.github.io/raw/master/image/51.gif)

ç°åœ¨ä¸Šé¢çš„è„šæœ¬å‘å¸ƒåï¼ˆåŒæ—¶ä¿®æ”¹ç‰ˆæœ¬ï¼‰ï¼š

![](https://github.com/cryer/cryer.github.io/raw/master/image/52.gif)

å®¢æˆ·ç«¯åœ¨æ¸¸æˆä¸­é€”ï¼Œå®æ—¶å°±ä¿®æ”¹äº†å†…éƒ¨çš„è¿è¡Œé€»è¾‘ï¼Œä¸éœ€è¦ä»»ä½•æ›´æ–°ä¸‹è½½ï¼Œä¸éœ€è¦é‡å¯æ¸¸æˆã€‚åŒæ—¶ï¼Œæˆ‘ä»¬ä¹Ÿæ³¨æ„åˆ°ï¼ŒèƒŒæ™¯å°±æ˜¯é»˜è®¤åˆ›å»ºçš„çº¿æ¡èƒŒæ™¯ï¼Œè¯´æ˜èƒŒæ™¯åŠ è½½æˆåŠŸã€‚

å†çœ‹èƒŒæ™¯çƒ­è¡¥ä¸éƒ¨åˆ†ï¼š

![](https://github.com/cryer/cryer.github.io/raw/master/image/152.jpg)

è®©å›¾ç‰‡è½¬åŒ–æˆBase64çš„æ ¼å¼è¿›è¡Œä¼ è¾“ï¼Œå®¢æˆ·ç«¯æœ¬åœ°ç”šè‡³éƒ½ä¸éœ€è¦å¯¹åº”çš„èµ„æºæ–‡ä»¶ï¼Œæ‰€ä»¥ä½ åœ¨è‡ªå·±ç©çš„æ¸¸æˆä¸­ä¼šå‘ç°æœ‰çš„èƒŒæ™¯UIå›¾ç‰‡ï¼Œè§£åŒ…éƒ½æ‰¾ä¸åˆ°ï¼Œå°±æ˜¯å› ä¸ºä¸éœ€è¦æœ¬åœ°æœ‰èµ„æºï¼ŒæœåŠ¡å™¨ç«¯ä¹Ÿå¯ä»¥å®æ—¶çƒ­è¡¥ä¸å‘å¸ƒã€‚å½“ç„¶å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œèµ„æºæ–‡ä»¶è¿˜æ˜¯å®¢æˆ·ç«¯ä¸‹è½½å¥½çš„ï¼Œæ­£å¸¸æ¸¸æˆéƒ½æ˜¯ä¸€æ¬¡æ›´æ–°ä¼šæŠŠæ¥ä¸‹æ¥æ›´æ–°çš„èµ„æºä¸‹è½½å¥½ã€‚

æˆ‘ä»¬ä¿®æ”¹å›¾ç‰‡ï¼Œçœ‹çœ‹æ•ˆæœï¼š

![](https://github.com/cryer/cryer.github.io/raw/master/image/155.jpg)

å¯ä»¥çœ‹åˆ°èƒŒæ™¯å®æ—¶å‘ç”Ÿäº†å˜åŒ–ï¼ŒåŒæ ·ï¼Œæˆ‘ä»¬æ¸…ç©ºBase64æ¡†ï¼Œç”¨çº¯RGBæ¥ä¿®æ”¹èƒŒæ™¯ï¼š

![](https://github.com/cryer/cryer.github.io/raw/master/image/154.jpg)

å¯ä»¥çœ‹åˆ°åŒæ ·æ²¡æœ‰ä»»ä½•é—®é¢˜ã€‚

### æ€»ç»“

åšå®¢ä¸»è¦è®²è§£äº†çƒ­è¡¥ä¸æ›´æ–°çš„æ–¹å¼ï¼Œå¦‚æœçœ‹å®Œäº†è¿™ä¸ªä»£ç ä¾‹å­ï¼Œç›¸ä¿¡å°±ä¼šå¯¹è¿™ç§æ›´æ–°æ–¹å¼æœ‰å¾ˆå¥½çš„äº†è§£ã€‚å†ç®€å•è¯´ä¸‹ç‰ˆæœ¬å¢é‡æ›´æ–°ï¼Œç‰ˆæœ¬å¢é‡æ›´æ–°å…¶å®å°±æ˜¯è®¡ç®—äºŒè¿›åˆ¶çš„å·®å¼‚ï¼Œæ¯”å¦‚**BSDiff**ç®—æ³•å’Œ**XDelta**ç®—æ³•ï¼Œéƒ½æ˜¯å¦‚æ­¤ï¼ŒæœåŠ¡å™¨ç«¯è®¡ç®—å·®å¼‚ä¹‹åï¼Œå®¢æˆ·ç«¯ä¸‹è½½å·®å¼‚æ›´æ–°è¡¥ä¸ï¼Œç„¶åç”¨å¯¹åº”ç®—æ³•çš„å·¥å…·åˆæˆå³å¯ï¼Œé…åˆä¸Šå®Œæ•´åº¦æ ¡éªŒï¼Œå°±æ˜¯ä¸€ä¸ªå¢é‡æ›´æ–°çš„æ–¹å¼ã€‚ç°ä»£æ¸¸æˆä¸€èˆ¬éƒ½æ˜¯å¢é‡è¡¥ä¸ï¼Œç‰ˆæœ¬æ¸…å•ï¼ŒCDNåˆ†å‘æ¥è¿›è¡Œç‰ˆæœ¬æ›´æ–°ã€‚






